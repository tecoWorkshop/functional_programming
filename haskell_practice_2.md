# Haskell 入門 (2)

## 再帰

再帰とは関数の定義内で自分自身を呼び出すこと

宣言的な定義を書く上で再帰がよく使われる

関数を再帰的に定義するには、問題を基底部まで小さく分解する

### 例）maximum 関数
順序付けできる値（Ord 型クラスのインスタンス）のリストを受け取り、その中で最も大きい値を返す
```
maximum' :: (Ord a) => [a] -> a
maximum' [] = error "maximum of empty list!"
maximum' [x] = x
maximum' (x:xs) = max x (maximum' xs)
```

1. リストが空ならエラーとなる
2. 単一要素のリストの場合はその値が最大値である（基底部）
3. head (x) と tail (xs) に分解し、 x と xs の最大要素を比較した大きい方が最大値である

※ パターンマッチは再帰関数の定義と相性がよい

### 例）take 関数
指定されたリストから指定された数の要素を返す
```
take' :: Int -> [a] -> [a]
take' n _
    | n <= 0 = []
take' _ []   = []
take' n (x:xs) = x : take' (n-1) xs
```

1. n が 0 以下の時は空のリストを返す（n が 0 より大きい場合はガード条件に合致しないので次のパターンに移る）
2. リストが空の場合は空のリストを返す
3. head (x) と tail (xs) に分解し、x と xs から (n-1) 要素取り出したものをリストにして返す

### 例）クイックソート
アルゴリズム

1. リストのある要素（ここでは先頭の要素）をピボットする
2. ピボット以下の要素をまとめたリストと、ピボットより大きい要素をまとめたリストに分ける
3. 分解した各リストに対して、1 と 2 を繰り返す

```
quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
        let smallerOrEqual = [a | a <- xs, a <= x]
            larger = [a | a <- xs, a > x]
        in quicksort smallerOrEqual ++ [x] ++ quicksort larger
```

1. リストが空の場合は空のリストを返す
2. リスト内包表記を使って、条件に合う 2 つのリスト smallerOrEqual と larger を束縛
3. それぞれのリストに対して自身を再帰的に呼び出し、リストを連結


## 高階関数
引数として関数を受け取ったり、戻り値として関数を返したりする関数を**高階関数**という

### カリー化
Haskell のすべての関数は、公式には引数を 1 つだけ取ることになっている

複数の引数を取る関数を、「元の関数の最初の引数を取り、元の関数の残りの引数を取る関数を返す」関数に変換することを**カリー化**という

#### 例）max 関数

* 最初に、 max が値 4 に適応される
* 5 に適応するための別の関数を返す
* この関数が 5 に適応されて最終的な数値を返す

以下の 2 つの呼び出しは等価となる
```
Prelude> max 4 5
5
Prelude> (max 4) 5
5
```

また、 max 関数の型は以下のようにも書ける
```
Prelude> :t max
max :: Ord a => a -> a -> a

max :: Ord a => a -> (a -> a)
```

関数を本来より少ない数の引数で呼び出したときに**部分適用**された関数が得られる
```
Prelude> :t max 4
max 4 :: (Num a, Ord a) => a -> a
```

### 高階関数の例
#### map
map 関数は、関数とリストを受け取り、その関数をリストのすべての要素に適用して、新しいリストを生成する
```
map' :: (a -> b) -> [a] -> [b]
map' _ [] = []
map' f (x:xs) = f x : map f xs
```

実例
```
*Main> map' (+3) [1,2,3]
[4,5,6]
*Main> map' (map' (^2)) [[1,2],[3,4,5,6],[7,8]]
[[1,4],[9,16,25,36],[49,64]]
```

#### filter
filter 関数は述語とリストを受け取り、そのリストの要素のうち述語を満たすものからなるリストを返す
```
filter' :: (a -> Bool) -> [a] -> [a]
filter' _ [] = []
filter' p (x:xs)
    | p x       = x : filter' p xs
    | otherwise = filter' p xs
```

実例
```
*Main> filter' (>3) [1,4,5,3,8,4,2]
[4,5,8,4]
*Main> filter' even [1..10]
[2,4,6,8,10]
```

### ラムダ式
* ラムダ式は、1回だけ必要な関数を作るときに使う無名関数
* 通常、高階関数に渡す関数を作るために使われる
* 構文
```
\ 引数 ... -> 関数本体
```

例）flip 関数
```
flip' :: (a -> b -> c) -> b -> a -> c
flip' f = \x y -> f y x

*Main> map (flip' subtract 20) [1,2,3,4]
[19,18,17,16]
```

### 畳み込み
* 畳み込みはデータ構造（リスト）を単一の値にまとめるときに使用する
* 畳み込みを使うと、リストを1要素ずつ一回だけ走査してそれに基づいた結果を返す関数を実装できる
* 畳み込み関数は、2引数関数と初期値（アキュムレータ）とリストを受け取る
* リストは左右どちらからでも畳み込める
* 畳み込み関数は、アキュムレータとリストの先頭要素を引数として、与えられた関数を呼び出し、その結果が新しいアキュムレータになる
* これをリスト全体を走査して、単一のアキュムレータの値になるまで繰り返す

例）左畳み込み
```
Prelude> :t foldl
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

Prelude> foldl (\acc x -> acc + x) 0 [1..10]
55
```

例）右畳み込み
```
Prelude> :t foldr
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

map'' :: (a -> b) -> [a] -> [b]
map'' f xs = foldr (\x acc -> f x : acc) [] xs

*Main> map'' (+3) [1,2,3]
[4,5,6]
```

### 関数合成
数学における関数合成は `(f ○ g)(x) = f(g(x))` のように書ける

Haskell における関数合成もほぼ同じで、`.` を使って関数合成ができる

関数合成は以下のように定義される
```
Prelude> :t (.)
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f (g x)
```

* f は引数として、 g の戻り値の型と同じ型を受け取る必要がある
* 合成された関数は、 g が受け取る型と同じ型の引数を受け取り、 f が返す型と同じ型の結果を返す

例）数のリストの全てを負の数に変換する（各要素の絶対値を取ってから符号を反転する）

ラムダ式を使う場合
```
Prelude> map (\x -> negate (abs x)) [5,-3,-6,7,-3,2,-19,24]
[-5,-3,-6,-7,-3,-2,-19,-24]
```

関数合成を使う場合
```
Prelude> map (negate . abs) [5,-3,-6,7,-3,2,-19,24]
[-5,-3,-6,-7,-3,-2,-19,-24]
```



